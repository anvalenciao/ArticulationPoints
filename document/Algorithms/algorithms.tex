% Encontrar los algoritmos que me permitan determinar en un grafo cuales son los nodos, en ultimas si los quito la cosa queda disconexa, una masa viscosa de puntos, otra masa viscosa de puntos, se tocan en un solo punto, el grafo es conexo, si yo quito ese nodo, entonces se partió en dos, esos puntos son claves en redes.

% https://www.geeksforgeeks.org/articulation-points-or-cut-vertices-in-a-graph/
% https://www.javamexico.org/system/files/Collections.pdf
% https://cs.stackexchange.com/questions/11177/how-to-check-whether-a-graph-is-connected-in-polynomial-time
% https://www.geeksforgeeks.org/difference-between-bfs-and-dfs/
% https://www.python-course.eu/graphs_python.php
% http://doc.sagemath.org/html/en/reference/graphs/index.html
% https://es.overleaf.com/learn/latex/algorithms
% https://math-linux.com/latex-26/faq/latex-faq/article/how-to-write-algorithm-and-pseudocode-in-latex-usepackage-algorithm-usepackage-algorithmic
% https://tex.stackexchange.com/questions/89574/language-option-supported-in-listings
% how to determine if a graph is connected
% https://github.com/mission-peace/interview/blob/master/src/com/interview/graph/ArticulationPoint.java
% https://en.wikipedia.org/wiki/Biconnected_component
% https://en.wikipedia.org/wiki/Robert_Tarjan

\lstdefinelanguage{JavaScript}{
	keywords={break, case, catch, continue, debugger, default, delete, do, else, finally, for, function, if, in, instanceof, new, return, switch, try, typeof, var, void, while, with},
	keywordstyle=\color{blue}\bfseries,
	ndkeywords={class, export, boolean, throw, implements, import, this},
	ndkeywordstyle=\color{cyan}\bfseries,
	identifierstyle=\color{black},
	morecomment=[l]{//},
	morecomment=[s]{/*}{*/},
	morestring=[b]',
	morestring=[b]",
	sensitive=true
}

\lstset{
	language=JavaScript,
	%extendedchars=true,
	basicstyle=\footnotesize\ttfamily,
	%showstringspaces=false,
	%showspaces=false,
	numbers=left,
	%numberstyle=\footnotesize,
	numbersep=9pt,
	tabsize=2,
	%breaklines=true,
	%showtabs=false,
	%captionpos=b
}

\renewcommand{\lstlistingname}{Algoritmo}% Listing -> Algorithm
\renewcommand{\lstlistlistingname}{Lista de \lstlistingname s}% List of Listings -> List of Algorithms

%\algnewcommand\algorithmicforeach{\textbf{for each}}
%\algdef{S}[FOR]{ForEach}[1]{\algorithmicforeach\ #1\ \algorithmicdo}

\section{Algoritmos}\label{algorithms}
lorem ipsum dolor sit amet.
/home/andres/Documentos/ArticulationPoints/document/Algorithms/code

\subsection{Algoritmo de Tarjan}
El algoritmo de Tarjan para encontrar puntos de articulación
\subsubsection{Pseudocódigo}
\begin{algorithm}
	\caption{Linear time depth first search}
	\begin{algorithmic}		
		\Function{GetArticulationPoints}{$i,d$}
			\State $visited[i] \leftarrow true$
			\State $depth[i] \leftarrow d$
			\State $low[i] \leftarrow d$
			\State $childCount \leftarrow 0$
			\State $isArticulation \leftarrow false$
			%\leq \geq \neq
			\ForAll{$ni$ \textbf{in} $adj[i]$}
				\If{not $visited[ni]$}
					\State $parent[ni] \leftarrow i$
					\State GetArticulationPoints($ni, d + 1$)
					\State $childCount \leftarrow childCount + 1$
					
					\If{$low[ni] \geq depth[i]$}
						\State $isArticulation \leftarrow true$
					\EndIf
					
					\State $low[i] \leftarrow Min(low[i], low[ni])$
					
				\ElsIf{$ni \neq parent[i]$}
					\State $low[i] \leftarrow Min(low[i], depth[ni])$
				\EndIf
			\EndFor
			
			\If{($parent[i] \neq null$ \textbf{and} $isArticulation$) \textbf{or} ($parent[i] = null$ \textbf{and} $childCount > 1$)}
				\State 
				\Return Output i as articulation point
			\EndIf
		\EndFunction
	\end{algorithmic}
\end{algorithm}

\lstinputlisting[label=samplecode, caption=sample code, language=JavaScript]{document/Algorithms/code/Tarjan.js}
\subsubsection{Complejidad}
